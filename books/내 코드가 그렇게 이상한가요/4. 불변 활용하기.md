# 불변 활용하기: 안정적으로 동작하게 만들기

참고

- https://velog.io/@haryan248/%EB%82%B4-%EC%BD%94%EB%93%9C%EA%B0%80-%EA%B7%B8%EB%A0%87%EA%B2%8C-%EC%9D%B4%EC%83%81%ED%95%9C%EA%B0%80%EC%9A%94-4%EC%9E%A5-%EC%A0%95%EB%A6%AC

## 4.1 재할당

변수에 값을 다시 할당하는 것을 재할당, 파괴적 할당이라고 한다. 재할당은 변수의 의미를 바꿔 추측하기 어렵게 만든다.

### 불변 변수로 만들어 재할당 막기

재할당을 막기 위해 변수를 다시 변경하지 못하도록 `final` 키워드를 사용해 막는다.

```java
void damage() {
    final int basicAttackPower = member.power() + member.weakAttack();
    final int finalAttackPower = (int)(basicAttackPower * (1 + member.speed() / 100));
    final int reduction = enemy.defence / 2;
    final int damage = Math.max(0, finalAttackPower - reduction);
}
```

### 매개변수도 불변으로 만들기

매개변수를 변경하면 값의 의미가 바뀔 수 있다. 그러므로 매개변수에도 `final` 키워드를 붙이면 된다.

```java
void addPrice(final int productPrice) {
    final int increasedTotalPrice = totalPrice + productPrice;
    if (MAX_TOTAL_PRICE < increasedTotalPrice) {
        throw new IllegalArgumentException("구매 상한 금액을 넘었습니다.");
    }
}
```

## 4.2 가변으로 인해 발생하는 의도하지 않은 영향

### 사례 1: 가변 인스턴스 재사용하기

```java
class AttackPower {
    static final int MIN = 0;
    int value;

    AttackPower(int value) {
        if (value < AttackPower.MIN) throw new IllegalArgumentException();
        this.value = value;
    }
}

class Weapon {
    AttackPower attackPower;

    Weapon(AttackPower attackPower) {
        this.attackPower = attackPower;
    }
}

// BAD: 재사용하는 값을 변경하면 두 가지에 모두 영향을 준다
AttackPower attackPower = new AttackPower(20);
Weapon weaponA = new Weapon(attackPower);
Weapon weaponB = new Weapon(attackPower);
weaponA.attackPower.value = 25;
// weaponA.attackPower.value = 25, weaponB.attackPower.value = 25

// GOOD: 별개의 인스턴스를 사용하면 영향을 끼치지 않는다
AttackPower attackPowerA = new AttackPower(20);
AttackPower attackPowerB = new AttackPower(20);
Weapon weaponA = new Weapon(attackPowerA);
Weapon weaponB = new Weapon(attackPowerB);
weaponA.attackPower.value = 25;
// weaponA.attackPower.value = 25, weaponB.attackPower.value = 20
```

### 사례 2: 함수로 가변 인스턴스 조작하기

```java
class AttackPower {
    static final int MIN = 0;
    int value;

    AttackPower(int value) {
        if (value < AttackPower.MIN) throw new IllegalArgumentException();
        this.value = value;
    }

    void reinforce(int increment) {
        this.value += increment;
    }

    void disable() {
        this.value = AttackPower.MIN;
    }
}
```

`disable` 메서드와 `reinforce` 메서드는 구조적인 문제를 가지고 있음

- 동일한 결과를 내기 위해서는 동일한 순서로 실행해야 한다. → 작업 실행 순서에 의존된다.(부수 효과가 발생)

**부수 효과의 단점**

- 부수 효과: 주요 작용 이외의 상태 변경을 일으키는 것
- 주요 작용: 함수(메서드)가 매개변수를 전달받고, 값을 리턴하는 것

**함수의 영향 범위 한정하기**

- 값은 함수의 리턴 값으로 돌려준다.
- 상태를 변경하지 않는다.
- 데이터(상태)는 매개변수로 받는다.

### 불변으로 만들어서 예기치 못한 동작 막기

```java
class AttackPower {
    static final int MIN = 0;
    private final int value;

    AttackPower(int value) {
        if (value < AttackPower.MIN) throw new IllegalArgumentException();
        this.value = value;
    }

    AttackPower reinforce(AttackPower increment) {
        return new AttackPower(this.value + increment.value);
    }

    AttackPower disable() {
        return new AttackPower(AttackPower.MIN);
    }

    int getValue() {
        return this.value;
    }
}

class Weapon {
    private final AttackPower attackPower;

    Weapon(AttackPower attackPower) {
        this.attackPower = attackPower;
    }

    Weapon reinforce(AttackPower increment) {
        AttackPower reinforced = this.attackPower.reinforce(increment);
        return new Weapon(reinforced);
    }

    AttackPower getAttackPower() {
        return this.attackPower;
    }
}

// weaponA와 reinforcedWeaponA는 서로 영향을 주지 않는 인스턴스로 생성이 가능하다
AttackPower attackPowerA = new AttackPower(20);
AttackPower attackPowerB = new AttackPower(20);
Weapon weaponA = new Weapon(attackPowerA);
Weapon weaponB = new Weapon(attackPowerB);
AttackPower increment = new AttackPower(5);
Weapon reinforcedWeaponA = weaponA.reinforce(increment);
// weaponA.getAttackPower().getValue() = 20
// reinforcedWeaponA.getAttackPower().getValue() = 25
// weaponB.getAttackPower().getValue() = 20
```

## 4.3 불변과 가변은 어떻게 다뤄야 할까

### 변수를 불변으로 만들 때의 장점

- 코드의 영향 범위가 한정적이므로, 유지 보수가 편리해짐
- 동작이 안정적이게 되므로, 결과를 예측하기 쉬움
- 변수의 의미가 변하지 않으므로, 혼란을 줄일 수 있음

### 가변으로 설계해야 하는 경우

성능이 중요한 경우에는 가변으로 처리하는 것이 좋은 경우도 존재

- 크기가 큰 인스턴스를 새로 생성하는데 시간이 오래 걸린다면 가변으로 사용하는 게 좋을 수 있다.

### 상태를 변경하는 메서드 설계하기

히트포인트와 멤버를 나타내는 클래스

- 히트포인트가 0이 되면, 사망 상태로 변경
- 히트포인트는 0 이상

```java
class HitPoint {
    private static final int MIN = 0;
    private int amount;

    HitPoint(int amount) {
        if (amount < HitPoint.MIN) throw new IllegalArgumentException();
        this.amount = amount;
    }

    void damage(int damageAmount) {
        int nextAmount = amount - damageAmount;
        this.amount = Math.max(HitPoint.MIN, nextAmount);
    }

    boolean isZero() {
        return amount == HitPoint.MIN;
    }
}

class Member {
    private HitPoint hitPoint;
    private States states;

    Member(int amount) {
        this.hitPoint = new HitPoint(amount);
    }

    void damage(int damageAmount) {
        this.hitPoint.damage(damageAmount);
        if (this.hitPoint.isZero()) {
            this.states.add(StateType.dead);
        }
    }
}
```

0이 되어도 사망 상태로 바꾸지 않는다. 상태를 변화시키는 메서드(뮤테이터)로 상태를 변경해야 한다.

### 코드 외부와 데이터 교환은 극소화하기

불변을 활용하더라도 코드 외부와의 데이터 교환은 주의해야 한다.

이를 위해 **리포지터리 패턴(Repository Pattern)**을 활용한다.

- 리포지터리 패턴: 데이터베이스 등 데이터 소스의 제어 로직을 캡슐화하는 패턴이다.
- 특정 클래스 내부에 데이터베이스 관련 로직을 격리하므로, 애플리케이션 로직이 데이터베이스 관련 로직과 섞이지 않는다.
